<b>1) Conhecimento adquiridos para construir a libft</b><br>
<li><a href="#entendendo">Entendendo melhor a Libft!</a></li>
<ol>
<br>
<i>Mandat√≥rio:</i>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_split">ft_split</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_strtrim">ft_strtrim</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_atoi">ft_atoi</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_itoa">ft_itoa</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_strnstr">ft_strnstr</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_strncmp">ft_strncmp</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_memcmp">ft_memcmp</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_substr">ft_substr</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_join">ft_join</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_strlcat">ft_strlcat</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_putnbr_fd">ft_putnbr_fd</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_strmapi">ft_strmapi</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_striteri">ft_striteri</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_strlcpy">ft_strlcpy</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_memcpy">memcpy</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_memmove">ft_memmove</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_strchr">ft_strchr</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_strrchr">ft_strrchr</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_memchr">ft_memchr</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_strdup">ft_strdup</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_calloc">ft_calloc</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_memset">ft_memset</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_bzero">ft_bzero</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_isalpha">ft_isalpha</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_isdigit">ft_isdigit</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_isalnum">ft_isalnum</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_isascii">ft_isascii</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_isprint">ft_isprint</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_strlen">ft_strlen</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_toupper">ft_toupper</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_tolower">ft_tolower</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_putstr_fd">ft_putstr_fd</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_putendl_fd">ft_putendl_fd</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_putchar_fd">ft_putchar_fd</a></li>
<br>
<i>B√¥nus:</i>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_lstnew">ft_lstnew</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_lstadd_front">ft_lstadd_front</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_lstsize">ft_lstsize</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_lstlast">ft_lstlast</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_lstadd_back">ft_lstadd_back</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_lstdelone">ft_lstdelone</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_lstclear">ft_lstclear</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_lstiter">ft_lstiter</a></li>
	<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ft_lstmap">ft_lstmap</a></li>
</ol>
<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#biblioteca">Que parada √© essa de bibliotecas em C?</a></li>
<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#makefile">Partiu dominar o 'Makefile'?</a></li>
<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#restrict">O que √© 'restrict' antes das vari√°veis? √© de comer?</a></li>
<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#ascii">Entenda de uma vez, o que √© ASCII? Unicode? UTF-8,16 e bla bla bla?</a></li>
<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#bases">Partiu dominar a convers√£o entre bases? üòéüëå</a></li>

<br>

<b>2) Brinde</b>
<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#outras">Outras Coisas Legais</a></li>
<li><a href="https://github.com/argelcapela/42-libft/blob/main/42-libft-study.md#fontes">Fontes</a></li>
</div>
<br>	

<h1>Atualiza√ß√µes em breve...</h1>
<br><br>
<h2 id="entendendo">Entendendo a Libft:</h2>
<b>Primeiramente... quantos fun√ß√µes existem no libft?</b>
<p>S√£o 45 fun√ß√µes no total. 36 Mandat√≥rias e 9 B√¥nus.<br>
N√£o tem segredo, √© um projeto trabalhoso n√£o dif√≠cil, com calma e paci√™ncia voc√™ consegui!</p>

<i>*N.O. Libc: S√£o fun√ß√µes que n√£o s√£o oficiais das bibliotecas padr√µes do C, mas sim, derivadas.</i><br><br>
<i>*As fun√ß√µes est√£o ordenadas da mais dif√≠cil para a mais f√°cil na minha opini√£o! üòÅ. Vc n√£o √© obrigado(a/e) a concordar!</i><br><br>
<i>*Muitas fun√ß√µes s√£o super f√°ceis de codificar, ent√£o somente as mais complexos apresentam um link do MIRO com o fluxograma indicando a l√≥gica que foi utilizada para desenvolv√™-la.</i><br>

<b>Vamos ver uma por uma?</b><br>
S√≥ se for agora truta! üòéüëå

<br><br>
<!--# 4 ft_split-->
<table id="ft_split">
<thead>
	<tr>
		<th colspan="4">ft_split</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria e retorna um array de strings obtido a partir da divis√£o de s, usando o caracter 'c' como delimitador.</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_split.c">char **ft_split(char const *s, char c);</a></td>
		<td>
			<ul>
				<li>Matriz de strings</li>
				<li>Nulo se a aloca√ß√£o de mem√≥ria falhar</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# 5 ft_strtrim-->
<table id="ft_strtrim">
<thead>
	<tr>
		<th colspan="4">ft_strtrim</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria e retorna uma c√≥pia de 's1' com cada caracter de 'set' removido do come√ßo e do fim de uma string.</td>
		<td>stdlib.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strtrim.c">char *ft_strtrim(char const *s1, char const *set);</a></td>
		<td>
			<ul>
				<li>String aparada, ou seja, com os caracteres cortados do come√ßo e do fim, se houver correspond√™ncia √© claro!</li>
				<li>Nulo se a aloca√ß√£o de mem√≥ria falhar</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# 2 atoi	-->
<table id="ft_atoi">
<thead>
	<tr>
		<th colspan="4"><a href="https://man7.org/linux/man-pages/man3/atoi.3.html">ft_atoi</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Converte de String para Inteiro</td>
		<td>stdlib.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_atoi.c">int atoi(const char *nptr);</a></td>
		<td>
			<ul>
				<li>O Valor convertido</li>
				<li>0 em caso de erro</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# 3 itoa	-->
<table id="ft_itoa">
<thead>
	<tr>
		<th colspan="4">ft_itoa</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria e retorna uma string representando o inteiro recebido como argumento</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_itoa.c">char *ft_itoa(int n);</a></td>
		<td>
			<ul>
				<li>A String representando o inteiro.</li>
				<li>NULL se a aloca√ß√£o falhar</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--# 1 strnstr
 -->
<table id="ft_strnstr">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=strnstr&sektion=3">ft_strnstr</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Retorna a primeira ocorr√™ncia de little dentro de big</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strnstr.c">char *strstr(const char *big, const char	*little);</a></td>
		<td>
			<ul>
				<li>Se little √© uma string vazia, retorna big</li>
				<li>Se little n√£o existe na string, retorna NULL</li>
				<li>Se little √© encontrado, um ponteiro para a primeira ocorr√™ncia de little dentro de big √© retornado.</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--# 6 ft_memcmp-->
<table id="ft_strncmp">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=strncmp&apropos=0&sektion=3&manpath=FreeBSD+13.0-RELEASE&arch=default&format=html">ft_strncmp</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Percorrer os primeiros 'n' bytes dos blocos de mem√≥ria 's1' e 's2' paralelamente, e retornar a diferen√ßa entre o valor ASCII de ambos. Com isso, podemos saber se duas strings s√£o iguais ou n√£o.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strncmp.c">int strcmp(const char *s1, const char *s2);</a></td>
		<td>
			<ul>
				<li>N√∫mero < 0 -> Se o "valor ASCII de algum caracter de 's1'" for menor que o "valor ASCII de outro caracter em 's2'" </li>
				<li>N√∫mero > 0 -> Se o "valor ASCII de algum caracter de 's1'" for maior que o "valor ASCII de outro caracter em 's2'" </li>
				<li>N√∫mero = 0 -> Se n√£o houver diferen√ßa entre os "valores ASCII 's1'" e os "valores ASCII de 's2'" </li>
				<li>Se 'n' √© zero, o valor de retorno √© zero</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# 6 ft_memcmp-->
<table id="ft_memcmp">
<thead>
	<tr>
		<th colspan="4"><a href="https://man7.org/linux/man-pages/man3/memcmp.3.html">ft_memcmp</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Percorrer os primeiros 'n' bytes dos blocos de mem√≥ria 's1' e 's2' paralelamente, e retornar a diferen√ßa entre o valor ASCII de ambos. Com isso, podemos saber se duas strings s√£o iguais ou n√£o.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_memcmp.c">int memcmp(const void *s1, const void *s2, size_t n);</a></td>
		<td>
			<ul>
				<li>N√∫mero < 0 -> Se o "valor ASCII de algum caracter de 's1'" for menor que o "valor ASCII de outro caracter em 's2'" </li>
				<li>N√∫mero > 0 -> Se o "valor ASCII de algum caracter de 's1'" for maior que o "valor ASCII de outro caracter em 's2'" </li>
				<li>N√∫mero = 0 -> Se n√£o houver diferen√ßa entre os "valores ASCII 's1'" e os "valores ASCII de 's2'" </li>
				<li>Se 'n' √© zero, o valor de retorno √© zero</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--# 7 ft_substr-->
<table id="ft_substr">
<thead>
	<tr>
		<th colspan="4">ft_substr</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria e retorna a string 's' aparada, come√ßando na posi√ß√£o 'start' e caminhando 'len' para frente. como assim ? A string retornada √© uma "substring", ou seja, uma string contida dentro de outra string. Por exemplo: 'argelcapela', se meu start √© 0, e meu len √© 5, o retorno √© 'argel' somente, ou seja, a string foi aparada, cortada, ou foi retornado um substring dessa string.</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_substr.c">char *ft_substr(char const *s, unsigned int start,
size_t len);</a></td>
		<td>
			<ul>
				<li>Substring de 's'</li>
				<li>NULL se a aloca√ß√£o de mem√≥ria falhar</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--# 8 ft_strjoin-->
<table id="ft_strjoin">
<thead>
	<tr>
		<th colspan="4">ft_strjoin</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria e retorna uma nova string, que √© o resultado da concatena√ß√£o ('jun√ß√£o') das strings 's1' e 's2'</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strjoin.c">char *ft_strjoin(char const *s1, char const *s2);</a></td>
		<td>
			<ul>
				<li>String nova concatena√ß√£o de 's1' e 's2'</li>
				<li>NULL se a aloca√ß√£o falhar.</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--# 9 ft_putnbr_fd-->
<table id="ft_putnbr_fd">
<thead>
	<tr>
		<th colspan="4">ft_putnbr_fd</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Printa um n√∫mero inteiro 'n' em um File Descriptor.</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_putbnr_fd.c">void ft_putnbr_fd(int n, int fd);</a></td>
		<td>
			<ul>
				<li>Nada</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--# 10 ft_strmapi-->
<table id="ft_strmapi">
<thead>
	<tr>
		<th colspan="4">ft_strmapi</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aplica a fun√ß√£o 'f' para cada caractere da string 's', resultando na cria√ß√£o de uma nova string modificada.</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strmapi.c">char *ft_strmapi(char const *s, char (*f)(unsigned
int, char));</a></td>
		<td>
			<ul>
				<li>A string criada pela sucessiva aplica√ß√£o de 'f'</li>
				<li>NULL se a aloca√ß√£o falhar</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--# 11 ft_striteri-->
<table id="ft_striteri">
<thead>
	<tr>
		<th colspan="4">ft_striteri</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aplica a fun√ß√£o 'f' em cada caractere da string 's'.</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_striteri.c">void ft_striteri(char *s, void (*f)(unsigned int,
char*));</a></td>
		<td>
			<ul>
				<li>Nada</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--# 12 ft_strlcpy-->
<table id="ft_strlcpy">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=strlcpy&sektion=3">ft_strlcpy</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Copia os primeiros 'size' caracteres da string 'src' para 'dst'.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strlcpy.c">size_t
     strlcpy(char * restrict dst, const	char * restrict	src, size_t dstsize);</a></td>
		<td>
			<ul>
				<li>Retorna o tamanho total de src.</li>
				<li>Se o valor de retorno for >= 'dstsize' a string de sa√≠da foi "TRUNCADA", ou seja, est√° cortada, inacabada ou imcompleta.</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--#  ft_memcpy-->
<table id="ft_memcpy">
<thead>
	<tr>
		<th colspan="4"><a href="https://man7.org/linux/man-pages/man3/memcpy.3.html">ft_memcpy</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Copia n bytes do bloco de mem√≥ria 'src' para o bloco de mem√≥ria 'dest'.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_memcpy.c">void *memcpy(void *restrict dest, const void *restrict src, size_t n);</a></td>
		<td>
			<ul>
				<li>Ponteiro para 'dest'</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--#  ft_memmove -->
<table id="ft_memmove">
<thead>
	<tr>
		<th colspan="4">ft_memmove</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Copia n bytes de um bloco de mem√≥ria 'src' para outro bloco de mem√≥ria 'dest'.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_memmove.c">void *memmove(void *dest, const void *src, size_t n);</a></td>
		<td>
			<ul>
				<li>Retorna um ponteiro para 'dest'</li>
				<li><i>A diferen√ßa entre os dois √© que no memcpy voc√™ tem que garantir que 'src' e 'dest' s√£o diferentes, ou pode gerar comportamento inesperado, por causa do restrict;</i></li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--# ft_strchr -->
<table id="ft_strchr">
<thead>
	<tr>
		<th colspan="4"><a href="https://man7.org/linux/man-pages/man3/strchr.3.html">ft_strchr</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Localiza a primeira ocorr√™ncia de 'c' dentro de 's'.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strrchr.c">char *strchr(const char *s, int c);</a></td>
		<td>
			<ul>
				<li>Retorna um ponteiro para o primeiro 'c' localizado em 's'</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--# ft_strrchr -->
<table id="ft_strrchr">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=strrchr&sektion=3&apropos=0&manpath=freebsd">ft_strrchr</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Localiza a √∫ltima ocorr√™ncia de 'c' dentro de 's'.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strrchr.c">char *strrchr(const char	*s, int	c);</a></td>
		<td>
			<ul>
				<li>Retorna um ponteiro para o √∫ltimo 'c' localizado em 's'</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>
<!--# ft_memchr -->
<table id="ft_memchr">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=memchr&sektion=3&apropos=0&manpath=freebsd">ft_memchr</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Localiza um byte 'c' dentro de uma cadeia de bytes.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_memchr.c">void *memchr(const void *b, int c, size_t len);</a></td>
		<td>
			<ul>
				<li>Retorna um ponteiro para o byte localizado;</li>
				<li>Retorna NULL se nenhum byte for encontrad;</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_strdup -->
<table id="ft_strdup">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?strdup(3)">ft_strdup</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria e realiza a c√≥pia de uma string</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strdup.c">char *strdup(const char *str);</a></td>
		<td>
			<ul>
				<li>Retorna um ponteiro para a string copiada</li>
				<li>Retorna NULL se n√£o h√° mem√≥ria insuficiente para alocar mem√≥ria e criar uma c√≥pia da string</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_calloc -->
<table id="ft_calloc">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=calloc&sektion=3&apropos=0&manpath=redhat">ft_calloc</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria para um array com um tamanho de 'nmemb', cada elemento contendo 'size' bytes, depois retorna um ponteiro para a √°rea alocada. A mem√≥ria desse bloco √© setada para zero</td>
		<td>stdlib.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_calloc.c">void *calloc(size_t nmemb, size_t size);</a></td>
		<td>
			<ul>
				<li>Retorna um ponteiro para a area da mem√≥ria alocada</li>
				<li>Retorna NULL se a aloca√ß√£o falhar</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_memset -->
<table id="ft_memset">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=memset&sektion=3&apropos=0&manpath=redhat">ft_memset</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Preenche a mem√≥ria com um byte</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_memset.c">void *memset(void *s, int c, size_t n);</a></td>
		<td>
			<ul>
				<li>Retorna um ponteiro para a area da mem√≥ria 's'</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_bzero -->
<table id="ft_bzero">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=bzero&sektion=3&manpath=FreeBSD+6.0-RELEASE">ft_bzero</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Preenche os primeiros 'len' bytes de um bloco de mem√≥ria com 0.</td>
		<td>strings.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_bzero.c">void bzero(void	*b, size_t len);</a></td>
		<td>
			<ul>
				<li>Nada</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_bzero -->
<table id="ft_bzero">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=bzero&sektion=3&manpath=FreeBSD+6.0-RELEASE">ft_bzero</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Preenche os primeiros 'len' bytes de um bloco de mem√≥ria com 0.</td>
		<td>strings.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_bzero.c">void bzero(void	*b, size_t len);</a></td>
		<td>
			<ul>
				<li>Nada</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_isalpha -->
<table id="ft_isalpha">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=isalpha&sektion=3&apropos=0&manpath=freebsd">ft_isalpha</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Testa se um caracter √© alfab√©tico</td>
		<td>ctype.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_isalpha.c">int isalpha(int c);</a></td>
		<td>
			<ul>
				<li>Zero se n√£o for um caracter alfab√©tico</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_isdigit -->
<table id="ft_isdigit">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=isdigit&sektion=3&apropos=0&manpath=freebsd">ft_isdigit</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Testa se um caracter √© n√∫mero de 0 a 9.</td>
		<td>ctype.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_isdigit.c">int isdigit(int c);</a></td>
		<td>
			<ul>
				<li>Zero se n√£o for um caractere entre 0 a 9.</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_isalnum -->
<table id="ft_isalnum">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=isalnum">ft_isalnum</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Testa se um caractere √© n√∫mero ou alfab√©tico</td>
		<td>ctype.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_isalnum.c">int ft_isalnum(int c);</a></td>
		<td>
			<ul>
				<li>Zero se caractere n√£o for um n√∫mero decimal ou n√£o for alfab√©tico</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_isascii -->
<table id="ft_isascii">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=isascii&sektion=3&apropos=0&manpath=freebsd">ft_isascii</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Testa se o caractere est√° presente na tabela ASCII</td>
		<td>ctype.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_isascii.c">int ft_isascii(int c);</a></td>
		<td>
			<ul>
				<li>Zero se o caractere n√£o estiver presente na tabela ASCII</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_isprint -->
<table id="ft_isprint">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=isprint&sektion=3&manpath=freebsd-release-ports">ft_isprint</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Testa se o caractere √© print√°vel, isto √©, que pode ser escrito na tela.<br><a href="#img-tabela-ascii">ver tabela ASCII</a></td>
		<td>ctype.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_isprint.c">int ft_isprint(int c);</a></td>
		<td>
			<ul>
				<li>Zero se o caractere n√£o estiver presente na tabela ASCII</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_strlen -->
<table id="ft_strlen">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=strlen&sektion=3">ft_strlen</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Retorna o tamanho de uma string, sem contar com o '\0'</td>
		<td>ctype.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strlen.c">size_t strlen(const char *s);</a></td>
		<td>
			<ul>
				<li>Retorna o n√∫mero de caracteres que precede o '\0'</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_toupper -->
<table id="ft_toupper">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=toupper&apropos=0&sektion=0&manpath=FreeBSD+7.2-RELEASE&format=html">ft_toupper</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Transforma um caractere na sua vers√£o maiscula.</td>
		<td>ctype.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_toupper.c">int toupper(int c);
</a></td>
		<td>
			<ul>
				<li>Retorna o n√∫mero ASCII da vers√£o mai√∫scula</li>
				<li>Retorna o endere√ßo ASCII do argumento passado se n√£o h√° mudan√ßa</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_tolower -->
<table id="ft_tolower">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=tolower&sektion=3&apropos=0&manpath=freebsd">ft_tolower</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Transforma um caractere na sua vers√£o min√∫scula.</td>
		<td>ctype.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_tolower.c">int ft_tolower(int c);
</a></td>
		<td>
			<ul>
				<li>Retorna o n√∫mero ASCII da vers√£o min√∫scula</li>
				<li>Retorna o endere√ßo ASCII do argumento passado se n√£o h√° mudan√ßa</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_putstr_fd -->
<table id="ft_putstr_fd">
<thead>
	<tr>
		<th colspan="4">ft_putstr_fd</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Escreve uma string em um File Descriptor</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_putstr_fd.c">void ft_putstr_fd(char *s, int fd);</a></td>
		<td>
			<ul>
				<li>Nada</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!-- # ft_putendl_fd -->
<table id="ft_putendl_fd">
<thead>
	<tr>
		<th colspan="4">ft_putendl_fd</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Escreve uma string em um File Descriptor seguido por um '\n'</td>
		<td>N.O. Libct</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_putendl_fd.c">void ft_putendl_fd(char *s, int fd);</a></td>
		<td>
			<ul>
				<li>Nada</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_putchar_fd -->
<table id="ft_putchar_fd">
<thead>
	<tr>
		<th colspan="4">ft_putchar_fd</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Escreve um caractere em um FD</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_putchar_fd.c">void ft_putnbr_fd(int n, int fd);</a></td>
		<td>
			<ul>
				<li>Nada</li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_lstnew -->
<table id="ft_lstnew">
<thead>
	<tr>
		<th colspan="4">ft_lstnew</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Escreve um caractere em um FD</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_lstnew.c">t_list *ft_lstnew(void *content);</a></td>
		<td>
			<ul>
				<li></li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_lstadd_front -->
<table id="ft_lstadd_front">
<thead>
	<tr>
		<th colspan="4">ft_lstadd_front</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td></td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_lstadd_front.c">void ft_lstadd_front(t_list **lst, t_list *new);</a></td>
		<td>
			<ul>
				<li></li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_lstsize -->
<table id="ft_lstsize">
<thead>
	<tr>
		<th colspan="4">ft_lstsize</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td></td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_lstnew.c">int ft_lstsize(t_list *lst);</a></td>
		<td>
			<ul>
				<li></li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_lstnew -->
<table id="ft_lstlast">
<thead>
	<tr>
		<th colspan="4">ft_lstlast</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td></td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_lstlast.c">t_list *ft_lstlast(t_list *lst);</a></td>
		<td>
			<ul>
				<li></li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_lstadd_back -->
<table id="ft_lstadd_back">
<thead>
	<tr>
		<th colspan="4">ft_lstnew</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td></td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_lstadd_back.c">void ft_lstadd_back(t_list **lst, t_list *new);</a></td>
		<td>
			<ul>
				<li></li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_lstdelone -->
<table id="ft_lstdelone">
<thead>
	<tr>
		<th colspan="4">ft_lstdelone</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Escreve um caractere em um FD</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_lstdelone.c">void ft_lstdelone(t_list *lst, void (*del)(void
*));</a></td>
		<td>
			<ul>
				<li></li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_lstclear -->
<table id="ft_lstclear">
<thead>
	<tr>
		<th colspan="4">ft_lstclear</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td></td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_lstclear.c">void ft_lstclear(t_list **lst, void (*del)(void *));</a></td>
		<td>
			<ul>
				<li></li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_lstiter -->
<table id="ft_lstiter">
<thead>
	<tr>
		<th colspan="4">ft_lstiter</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td></td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_lstiter.c">void ft_lstiter(t_list *lst, void (*f)(void *));</a></td>
		<td>
			<ul>
				<li></li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<!--# ft_lstmap -->
<table id="ft_lstmap">
<thead>
	<tr>
		<th colspan="4">ft_lstmap</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td></td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_lstmap.c">t_list *ft_lstmap(t_list *lst, void *(*f)(void *),void (*del)(void *));</a></td>
		<td>
			<ul>
				<li></li>
			</ul>
		</td>
	</tr>
</tbody>
</table>
<br>

Exemplo:

```

```

Sa√≠da:

```

```

<br><br>

<a href="https://www.gnu.org/software/make/manual/make.html"><h2 id="makefile">Partiu dominar o 'Makefile'?</h2></a>
<br>
<b>O que √© Makefile?</b>
<p>Arquivo que cont√©m v√°rios comandos Shell organizados para serem executados automaticamente, toda vez que voc√™ da o comando make. Em poucas palavras, um automatizador de comandos. O objetivo primordial do Makefile segundo muitos portais √© automatizar comandos para: primeiro compilar arquivos de c√≥digo fonte (.c) transformando-os em arquivo objeto, segundo, realizar a "linkedi√ß√£o", transformando esses arquivos objeto (.o) em arquivos bin√°rios, execut√°veis. (.exe/.out/.elf/etc). Ent√£o √© isso, o Makefile serve para, depois que a gente organiza ele bonitinho, ele faz todo o trabalho pra gente sempre que precisar-mos.</p>
<br>
<br>
<b>Que mais?</b>
<br>

```
# sintax das diretivas de um makefile comum

alvo: pr√©-requisito
<tab> receita
```
<br><br>

```
# alvo:
# - Nome da a√ß√£o a ser executada
# - Mais comum colocar o nome do arquivo a ser gerado;

# pr√©-requisito:
# - Outros alvos, que ser√£o executados, ou criados, antes de executar esse alvo em quest√£o, geralmente os pr√©-requisitos vem depois e n√£o antes, √© como se o Makefile fosse escrito de tr√°s para frente, do √∫ltimo arquivo a ser gerado para o primeiro. (Estranho n√©, mas √© o que eu vejo por ai.. S√≥ aceita.. üôÑüòõ)
# - Arquivos que s√£o necess√°rios para gerar o nosso "alvo";

# receita:
# - Comandos SHELL eeeee, f√°cil.
# - Comandos para executar a a√ß√£o que nosso alvo deseja, ou gerar um arquivo desejado.
```

<br><br><br>
<b>Nomes de Targets(Alvos) padr√µes para projetos da 42</b>
```
all -> Executa assim que o comando make √© executado;

bonus -> Para compilar o b√¥nus dos projetos;

fclean -> Deleta os .o files junto com os .a files do projeto;

clean -> Deleta todos os .o files;

.PHONY -> aqui colocamos os targets que somente executam procedimentos, sem criar um arquivo com seus respectivos nomes. PHONY garante que essas targets sempre ser√£o executadas, evitando bugs de conflito com arquivos que tenham o mesmo nome que os targets.

```

<br><br>
<b>Exemplo de Makefile simples para compilar um programinha simples de Hellowolrd:</b>
<br>
<i>hellowolrd.h</i>

```
#ifndef HELLO_WOLRD_H
#define HELLO_WOLRD_H

#include <stdio.h>
#include <string.h>

char *hello_wolrd();

#endif
```

<br><br><br>
<i>hellowolrd.c</i>

```
#include "hellowolrd.h"

char *hello_wolrd()
{
	return (strdup("Hello Wolrd!"));
}
```

<br><br><br>
<i>hellowolrd.c</i>

```
#include "hellowolrd.h"

char *hello_wolrd()
{
	return (strdup("Hello Wolrd!"));
}
```

<br><br><br>
<i>main.c</i>

```
#include "hellowolrd.h"

int main(void)
{
	char *resposta = hello_wolrd();
	printf("%s", resposta);
	return (0);
}

```

<br><br><br>
<i>Makefile</i>

```
all: hellowolrd

hellowolrd: main.o hellowolrd.o
	gcc -o hellowolrd main.o hellowolrd.o hellowolrd.h

# arquivo.h n√£o √© obrigat√≥rio mas..
# se n√£o √© colocado no gcc final, √© gerado um arquivo chato (.h.gch)

main.o:
	gcc -o main.o -c main.c

hellowolrd.o:
	gcc -o hellowolrd.o -c hellowolrd.c

clean:
	rm -f *.out *.o *.gch

```
<br>
<ol>
	<li>Quando executamos o comando make, makefile automaticamente busca o alvo all, sempre.</li>
	<li>O alvo all, quer ser executado e verifica se tem algum pr√©-requisito, ele precisa de um arquivo, ou alvo chamado hellowolrd, ent√£o ele segui a pr√≥xima linha e encontra o que estava buscando e executa a diretiva hellowolrd.</li>
	<li>Essa por sua vez, precisa executar outras duas chamadas main.o e hellowolrd.o, antes de executar seus comandos.</li>
	<li>main.o e helloworld.o n√£o precisam de nenhum pr√©-requisito ent√£o s√≥ executam seus comandos.</li>
	<li>Assim como em fun√ß√µes recursivas (ü§® P√©ssimo exemplo, programador odeia isso! üò¨) depois que a condi√ß√£o de encerramento √© verdadeira, a fun√ß√£o volta de tr√°s para frente executando todo o restante. Ou seja, as condi√ß√µes aqui eram a cria√ß√£o dos arquivos main.o e hellowolrd.o, ent√£o logo volta pro alvo hellowolrd e volta pro alvo all.</li>
</ol>

<br><br><br>
<b>Macros e Vari√°veis Autom√°ticas</b>
<br>

```
# sintax diretiva makefile (usando macros)
# calma, n√£o sai correndo, beba √°gua, vamos estudar direitinho üòéüòù

%.o: %.c %.h
<tab> @$ <$

# % -> Pega o nome antes do .;

# $@ -> Pega o nome do target(alvo);

# %< -> Pega o primeiro pr√©-requisito;

```
<br><br><br>

<b>Pegando exemplo anterior, podemos tornar nosso Makefile mais inteligente:</b><br>
<br>
<i>Makefile otimizado:</i>

```
SRCS= $(wildcard *.c)

OBJS= $(SRCS:.c=.o)

# se $(OBJS) for usado como pr√©-requisito e n√£o tiver nenhum comando para compilar os objetos, esse cara, faz automaticamente a compila√ß√£o dos objetos com o comando cc -o -c certinho;

all: hellowolrd

hellowolrd: $(OBJS)
	gcc -o $@ $^

%.o: %.c
	gcc -Wall -Wextra -Werror -o $@ -c $<

re: fclean all

fclean: clean
	rm -f *.out hellowolrd

clean:
	rm -f *.o *.gch

#se o .h n√£o √© colocado no gcc final √© gerado um arquivo (.h.gch) mas n√£o √© obrigat√≥rio...

```

<p>Agora √© s√≥ praticar, testar, praticar mais e n√£o esque√ßa, a documenta√ß√£o <a href="https://www.gnu.org/software/make/manual/make.html"> OFICIAL </a> ,√© sua melhor amiga</p>
<br><br>

<h2 id="biblioteca">Que parada √© essa de bibliotecas em C?</h2>
<br>
<img src="https://github.com/argelcapela/42-trilha-de-fundamentos/blob/main/makefile/compilation-and-linker.jpg?raw=true" alt="Compilation and Linker!">
<br>
<b>Vamos entender um pouco mais sobre o GCC e <a href="https://www.freebsd.org/cgi/man.cgi?query=ar&sektion=1">AR</a>?</b>
<br>

```
# -c significa compiler, ou seja, ele vai transformar um arquivo de c√≥digo fonte em um arquivo (.o) arquivo de objeto.
gcc -c arquivo.c

# -o significa output, mas trata-se do linker, ou seja, ir√° transformar um arquivo (.o) em um arquivo execut√°vel.
gcc -o <nome arquivo de sa√≠da> arquivos.o

# sem as flags -c e -o, o gcc faz tudo junto, transforma em .o e j√° transforma no execut√°vel padr√£o a.out/a.exe;
gcc arquivo.c

# ar -> Junta objetos.o e cria uma biblioteca.a
# r -> Se a biblioteca j√° existe, substitui os arquivos antigos;
# c -> Cria se n√£o existe;
# s -> Cria um indice para as fun√ß√µes da biblioteca, assim o acesso fica mais r√°pido, tipo ID de tabela SQL ao
# invez do nome completo;
ar rcs <nome_biblioteca.a> <objetos.o...>
```

<br><br>
<h2 id="restrict">O que √© 'restrict' antes das vari√°veis? √© de comer?</h2>
<b>Que tr√≥√ßo √© Restrict Type Qualifier?</b>
<p>Ele √© usado somente em ponteiros, ele √© uma promessa, diz para o compilador que esse ponteiro √© o √∫nico ponteiro que est√° apontando para o valor apontado, √© o √∫nico caminho par acessar o valor apontado. Como assim J√∫nior? Vamos l√°! Imagina que temos um ponteiro chamado (int* restrict num1) que est√° apontando para o n√∫mero um n√∫mero 10 qualquer, o restrict promete para o compilador que nenhum outro ponteiro est√° apontando para esse mesmo n√∫mero 10. O restrict n√£o afeta nada no c√≥digo em si, mas sim, no modo como o Assembly, ou o compilador executa o c√≥digo, se a promessa do restrict n√£o for respeitada, v√°rios erros podem ser gerados no c√≥digo, por√©m se usado corretamente, pode tornar uma aplica√ß√£o muito mais r√°pida. <br> Bora de exemplo?</p>

```
void updatePtrs(size_t *ptrA, size_t *ptrB, size_t *val)
{
  *ptrA += *val;
  *ptrB += *val;
}
```

```
; C√≥digo Assembly RISC Machine (hipot√©tico)
ldr r12, [val]     ; Carrega/"Copia" a mem√≥ria alocada apontada por [val] no registrador r12
ldr r3, [ptrA]     ; Carrega/"Copia" a mem√≥ria alocada apontada por [ptrA] no registrador r3
add r3, r3, r12    ; Executa uma soma entre os registradores: r3 = r3 + r12.
str r3, [ptrA]     ; Pega o valor do registrador r3 e joga na mem√≥ria alocada apontada por ptrA.
ldr r3, [ptrB]     ; Espera at√© a opera√ß√£o anterior terminar / Carrega o valor da vari√°vel [ptrB] no registrador r3
ldr r12, [val]     ; Carrega/"Copia" a mem√≥ria alocada apontada por [val] no registrador r12 de novo. Por que?
                   ; porque se o ponteiro val ou ptrA apontarem para o mesmo local, depois da soma feita anteriormente, o valor de val ser√° diferente, ent√£o, o compilador
                   ; precisa ler de novo para garantir que o valor est√° correto.
add r3, r3, r12    ; Executa a soma r3 = r3 + r12
str r3, [ptrB]     ; Pega o valor do registrador r3 e joga na mem√≥ria alocada apontada por ptrA.
```

<p>O Compilador sem o restrict faz uma verifica√ß√£o pra saber se o valor de val mudou, caso val apontasse para o mesmo bloco de mem√≥ria que os demas ponteiros. </p>


```
void updatePtrs(size_t *restrict ptrA, size_t *restrict ptrB, size_t *restrict val)
{
  *ptrA += *val;
  *ptrB += *val;
}
```

```
; C√≥digo Assembly RISC Machine (hipot√©tico)
ldr r12, [val]  ; Aqui o registrador r12 carrega o bloco de mem√≥ria apontado por [val] somente uma vez. Porque o restrict, garante pro compilador que esse ponteiro √© o √∫nico                     ; caminho ou seja, esse valor n√£o vai mudar nas outras opera√ß√µes.
ldr r3, [ptrA]  ; Carrega os blocos de mem√≥ria apontados pelos ponteiros [ptrA] e [ptrB] nos respectivos registradores r3,r4.
ldr r4, [ptrB]
add r3, r3, r12 ; Executa as opera√ß√µes de adi√ß√£o.
add r4, r4, r12
str r3, [ptrA]  ; Executa as opera√ß√µes de atualiza√ß√£o.
str r4, [ptrB]
```

<p>Agora quando, eu coloco o restrict, o compilador n√£o precisa fazer verifica√ß√µes de consist√™ncia, ele vai direto ao ponto, s√≥ carrega e executa as opera√ß√µes.</p>
<i>Nesse exemplo simples, pode parecer pouco relevante por√©m, o uso correto do restrict em aplica√ß√µes mais complexos torna a aplica√ß√£o mais r√°pida.</i>
<br><br>

<h2 id="ascii">Entenda de uma vez, o que √© ASCII? Unicode? UTF-8,16 e bla bla bla?</h2>
<br>
<b>O que √© ASCII?</b>
<p>(American Standard for Comunication and Information Interchange) C√≥digo Padr√£o Americano para o Interc√¢mbio de Informa√ß√£o. √â uma tabela que foi criada para ajudar os americanos na √©poca para enviar mensagens entre si, trata-se de uma tabela com de at√© 7 bits, ou seja, 128 caracteres no m√°ximo (contando com o 0). A ideia √© que cada caracter √© convertido em um valor bin√°rio de 7bits para que o computador entenda, envie esses bits, e outro computador, leia esses bits, e converta-os novamente no caracter correspondente na tabela ASCII.</p>
<img src="https://i.imgur.com/ukA7MRd.png" alt="tabela ascii" width="100%">
<p>A Tabela ASCII extendida, funciona do mesmo modo que a primeira, por√©m com o acr√©scimo do √∫ltimo byte, agora os valores s√£o de at√© 8 bits, ou seja 255 caracteres diferentes( contando como 0). Podemos notar que n√£o s√£o s√≥, caracteres, temos s√≠mbolos tamb√©m.<br> Agora imagine, o mundo √© enorme, ent√£o os outros alfabetos do mundo n√£o podem ser representados pela tabela ASCII, para isso, surgiu a necessidade de um novo amigo o Unicode.</p>
<img src="https://i.imgur.com/uuGT9ZT.png" alt="tabela ascii extended" width="100%">
<br><br><br>
<b>O que √© Unicode?</b>
<p>("Um c√≥digo")Eu entendo como uma tabelona gigante, de at√© 32bits, ou seja, com a capacidade de armazenar at√© 2 bilh√µes de caracteres. Pra que tudo isso ? Simples, cada pais sem sua pr√≥pria "tabela ASCII" para envio de informa√ß√µes entre sistemas no seu pr√≥prio idioma, o Unicode √© a organiza√ß√£o de todas essas tabelas "ASCIIs" do mundo numa tabelona s√≥. Cada caracter dessa tabelona, √© represetando por um cara chamado "Code Point", um n√∫mero hexadecimal, olha que maravilha. Por√©m o Unicode por si s√≥, n√£o resolve todo o BO, por que? Os gringos receberam a primeira fatia do Unicode, ent√£o pra eles √© como se n√£o fizesse diferen√ßa, mas o restante do mundo, precisa criar algoritmos de codifica√ß√£o, queee?? isso mesmo, os carinhos que v√£o pegar os bytes enviados do EUA para o Jap√£o, analisar, "traduzir" esse ingl√™s, requesenta qual code point na tablea Unicode, ent√£o traduzido, traduzir tamb√©m em bin√°rio e exibir bonitinho no PC Japon√™s. √â um rol√™ muito complexo, mas o UTF-8 vem se destacando, se tornando o padr√£o.   </p>
<br><br>
<b>UTF-8?</b>
<p>Unicode Transformation Format (Formato de transforma√ß√£o Unicode). Como explicado anteriormente, esse cara "traduz do idioma local para o Unicode universal" e vice versa, de um modo otimizado. Dessa forma realizando a perfeita troca de informa√ß√µes entre sistemas de regi√µes distintas.</p>
<br><br>

<h2 id="bases">Partiu dominar a convers√£o entre bases? üòéüëå</h2>
<br>
<b>Decimal para Hexa?</b>

<br><br>
<b>Hexa para Decimal?</b>

<br><br>
<b>Hexa para Bin√°rio?</b>

<br><br>
<b>Bin√°rio para Hexa?</b>

<br><br>
<b>Decimal para Bin√°rio?</b>

<br><br>
<b>Bin√°rio para Decimal?</b>


<br><br>
<h2 id="outras">Outras coisas legais!</h2>

<h4>Trabalhando com Arquivos de cabe√ßalho & #Include Guards</h4>
<p>N√≥s podemos modularizar nossos projetos em C, utilizando arquivos de cabe√ßalho, como assim ? Se n√≥s temos um c√≥digo grande pra fazer, mas queremos separar em arquivos C diferentes, por exemplo na GNL, pr√≥ximo projeto, um arquivo √© para a fun√ß√£o GNL, outro √© para as fun√ß√µes aux√≠liares, para isso podemos trabalhar com arquivos .h, ou arquivos de cabe√ßalho.</p>

<b>Por que usamos ifndef?</b>
<p>Em poucas palavras, essa manobra √© conhecida como Include Guard, basicamente √© impedir que a mesma coisa seja feita mais de uma vez.</p>

```
#ifndef _INCL_GUARD
#define _INCL_GUARD
    /* c√≥digo a ser executado caso _INCL_GUARD ainda n√£o tenha sido criado no programa */
#else
    /* c√≥digo a ser executado caso _INCL_GUARD j√° tenha sido criado, ou seja, sempre deixamos vazio para o programa n√£o adicionar 2x o arquivo.h e bugar o programa. */
#endif
```


<b>get_next_line.h</b>

```
#ifndef GET_NEXT_LINE_H
# define GET_NEXT_LINE_H

/*
 * Aqui v√£o os prot√≥tipos de todas as fun√ß√µes que ser√£o utilizadas no projeto
 *
 */

#endif
```

<b>get_next_line.c/_utils.c</b>

```
#include "get_next_line.h" // inclu√≠ os prot√≥tipos criados no header dentro do projeto.

/*
 * agora podemos criar as fun√ß√µes aqui, e elas podem ser enxergadas por todos os arquivos C que estiverem vinculados com o arquivo.h.
 * isso √© legal para organizar o projeto.
 */

```

<br><br><br><br>

```
int i = 1, j;
j = i++;
```
<p>i++ √© conhecido como Post Increment('Incrementador Depois'), ou seja, ele s√≥ vai adicionar + 1 ao valor de i, <u>depois que todas as opera√ß√µes da linha terminarem.</u></p>

```
int i = 1, j;
j = ++i;
```
<p>++i √© conhecido como Pre Increment('Incrementador Antes'), ou seja, ele vai adicionar 1 ao valor de i, <u>antes que qualquer opera√ß√£o da linha seja executada.</u></p>


<br><br><br><br>

```
#include <stdio.h>
#include <string.h>

int main()
{
    char empty[5] = { '\0' };
    char null[5];

    if( strcmp(empty,null)==0 )
        puts("Strings are the same");
    else
        puts("Strings are not the same");

    return(0);
}
```
<br><br>

```
char *null;
char null2[5];
char *null3 = NULL;
char vazia[5] = {'\0'};

printf("asdf: %s \n", null);
printf("%s \n", null2);
printf("%s \n", null3);
printf("%s \n", vazia);
```
<br>
<li>String vazia √© uma string que cont√©m 0 caracteres exceto o '\0'.</li>
<li>String Nula √© uma string que foi declarada, tendo alocado mem√≥ria ou n√£o, por√©m n√£o foi inicializada, ou seja, apresenta lixo de mem√≥ria e comportamento inesperado.Quando apontamos uma string para NULL, estamos dizendo que ela est√° apontando para uma posi√ß√£o NULA, s√≥ isso, s√≥ vai impedir ela de pegar MEMORY GARBAGE e pode facilitar o uso de if com essa vari√°vel, mas ela √© NULA e pronto, n√£o aponta para nada!</li><br>
<i>*Pode ser confuso porque algumas fun√ß√µes retornam que uma string √© (null) se n√£o tiver valor dentro dela, mas n√£o confundam, s√£o duas coisas diferentes.</i></p>
<br><br><br><br>


<div>
<h2 id="fontes">Fontes</h2>
<li><a href="https://www.gnu.org/software/make/manual/make.html">Documenta√ß√£o Oficial Makefile</a></li>
<li><a href="https://qastack.com.br/programming/2145590/what-is-the-purpose-of-phony-in-a-makefile">.PHONY</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#Overall-Options">Documenta√ß√£o Oficial GCC -o and -c</a></li>
<li><a href="https://www.embarcados.com.br/introducao-ao-makefile/">Tutorial simples e foda de Makefile</a></li>
<li><a href="https://www.tutorialspoint.com/cprogramming/c_header_files.htm">C Header Files</a></li>
<li><a href="https://en.wikipedia.org/wiki/Include_guard">#Include Guard</a></li>
<li><a href="https://stackoverflow.com/questions/24853/what-is-the-difference-between-i-and-i">Diferen√ßa entre ++i e i++!</a></li>
<li><a href="https://c-for-dummies.com/blog/?p=2641">Diferen√ßa entre NULL e String Vazia</a></li>
<li><a href="https://www.youtube.com/watch?v=MijmeoH9LT4">Gringo muito louco, explicando ASCII e Unicode</a></li>
<li><a href="https://www.treinaweb.com.br/blog/uma-introducao-a-ascii-e-unicode">B√°sico ASCII, Unicode e UTF-8</a></li>

</div>
<br><br><br>
